## 变量与可变性
- Rust的变量默认是不可变的，为了能够安全且方便地写出复杂、甚至是并行的代码
- 设计一个变量的可变性还需要考量许多因素:例如当你在使用某些重型数据结构时，适当地使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效率;而当数 据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量 来进行赋值，可能会使代码更加易于理解。在类似这样的情形下，为了可读性而损失少许的性能也许是值得的

### 变量与常量之间的不同
- 不能用mut关键字来修饰一个常量。常量不仅是默认不可变的，它还总是不可变的
- 需要使用const关键字而不是let关键字来声明一个常量。声明的同时需要显式地标注值的类型
- 常量可以被声明在任何作用域中，甚至包括全局作用域
- 只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上

### 隐藏
- 一个新声明对的变量可以覆盖旧的同名变量
- 第一个变量被第二个变量隐藏了
- 可以重复使用let关键字并配以相同的名称来不断地隐藏变量
- 隐藏机制不同于一个变量声明为mut，因为如果不是在使用let关键字的情况下重新为这个变量赋值，则会导致编译错误
- 使用let，我们可以对这个值执行一系列的变换操作，并允许这个变量在操作后保持自己的不可变性
- 隐藏机制于mut的另一个区别在于：由于重复使用let关键字会创建出新的变量，所以可以复用变量名称的同时改变它的类型

## 数据类型
- rust中的每一个值都有其特定的数据类型
  - 标量类型 scalar
  - 复合类型 compound
- rust静态语言，在编译程序的过程中需要知道所有变量的具体类型
### 标量类型
1. 标量：类型是单个值类型的统称
2. 整数、浮点数、布尔值及字符
3. 整数：没有小数部分的数字
  - 8-bit: i8, u8
  - 16-bit: i16, u16
  - 32-bit: i32, u32
  - 64-bit: i64, u64
  - arch: isize, usize: 它们的长度取决于程序运行的目标平台。在64位架构上，它们就是64 位的，而在32位架构上，它们就是32位的。
- 除了Byte，其余所有的字面量都可以使用类型后缀
| 整数字面量 | 实例 |
| --- | --- |
| Decimal | 98_222 |
| Hex | 0xff |
| Octal | 0o77 |
| Binary | 0b1111_0000 |
| Byte(u8 only) | b'A' |
- rust对于整数字面量的默认推导类型i32，在大部分情况下是运算速度最快的那一个
- usize和isize主要用作某些集合的索引
4. 浮点数类型
- 带小数的数字：f32，f64
5. 数值运算
- `+`, `-`, `*`, `/`, `%`
6. 布尔类型
- true/false，占据单个字节的空间大小,可以使用bool来表示一个布尔类型
- 主要的用途在if表达式内作为条件使用
7. 字符类型
- char类型被用于描述语言中最基础的单个字符
- 但需要注意的是：char类型使用单引号指定，而不同于字符串使用双引号指定
- char类型占4字节，是一个Unicode标量值，意味着可以表达比ASCII多得多的字符内容

### 复合类型
- rust提供了两种内置的基础复合类型：元组tuple和数组array
1. 元组类型
- 将其他不同类型的多个值组合进一个复合类型中
- 元组拥有一个固定的长度: 无法在声明结束后增加或减少其中的元素数量
```rust
fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
- 一个元组被视作一个单独的复合元素，tup被绑定到了整个元组上
- 模式匹配来解构元组`let (x, y, z) = tup;`
- 通过索引并使用dot来访问元组中的值`x.0, x.1`
2. 数组类型
- 可以在数组中储存多个值的集合
- 数组中的每一个元素都必须是相同的类型。rust中的数组拥有固定的长度，一旦声明不能随意更改大小
```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
}
```
- 想在栈上而不是在堆上为数据分配空间时，或者想要确保固定数量的元素时，数组是一个非常有用的工具
- rust标准库也提供了一个更灵活的动态数组vector类型。动态数组时一个类似于数组的集合结构，但它允许用户自由地调整数组长度。如果不确定就使用动态数组
```rust
let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September","October", "November", "December"];
```
数组的类型，使用一对方括号，并在方括号中填写数组内所有元素的类型、一个分号及数组内元素的数量
```rust
// i32便是数组内所有元素的类型，而分号之后的5则表明 当前的数组包含5个元素
let a: [i32; 5] = [1, 2, 3, 4, 5];
```
创建数组类型的方式有些类似于另一种初始化数组的语法，即加入你想要创建一个含有相同元素的数组，可以在方括号中指定元素的值，并接着填入一个分号及数组的长度
```rust
let a = [3; 5];
```
以a命名的数组将会拥有5个元素，而这些元素全部拥有相同的初始值3。这一写法等价于let a = [3, 3, 3, 3, 3];，但却更加精简.
3. 访问数组的元素
数组由一整块分配在栈上的内存组成，你可以通过索引来访问一 个数组中的所有元素. `a[0], a[1]`
4. 非法的数组元素访问 
- 访问超过数组长度的索引时，程序会通过编译但是在运行时会因为错误而崩溃退出
- 一旦尝试使用非法索引，你就会访问到 某块无效的内存。在这种情况下，逻辑上的错误常常会蔓延至程序的 其他部分，进而产生无法预料的结果。通过立即中断程序而不是自作 主张地去继续运行，Rust帮助我们避开了此类错误

## 函数
- 函数定义在fn关键字开始并紧随函数名称与一堆圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方

### 函数参数
- 一种特殊的变量，并被视作函数签名的一部分。当函数存在参数时，需要在调用函数时为这些边领提供具体的值
- 参数变量和传入的具体参数值有自己分别对应的名称paramater和argument
- 在函数签名中，必须显式地声明每个参数的类型
```rust
fn function(x: i32, y: i32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```
- 函数参数可以是不同类型的

### 函数体中的语句和表达式
- 由于Rust是一门基于表达式的语言，所以它将语句 (statement)与表达式 (expression)区别为两个不同的概念，这与其他某些语言不同。
- 语句：那些执行操作但不返回值的指令
- 表达式：会进行计算并产生一个值作为结果的指令
```rust
let y = 6;
let x = (let y = 6); // 无效：因为作为语句不会有返回值，导致x无法初始化
```
C语言或Ruby语言中的赋值 语句会返回所赋的值。在这些语言中，你可以编写类似于x = y = 6这 样的语句，并使得x和y变量同时拥有6这个值，但这在Rust中可行不通。

调用函数是表达式，调用宏是表达式，用来创建新作用域的花括号`{}`同样也是表达式
```rust
fn main() {
  let x = 5;
  let y = {
    let x = 3;
    x + 1
  };
  println!("The value of y is {}", y);
}
```

### 函数的返回值
- 函数可以调用它的代码返回值。不用为这个返回值命名，但是需要在箭头符号(`->`)后面声明它的类型。函数的返回值等同于函数题最后一个表达式的值。可以使用return关键字并指定一个值来提前从函数中中返回，但大多数函数都隐式地返回最后的表达式
```rust
fn five() -> i32 {
  5
}

fn main() {
  let x = five();
  println!("The value of x is: {}", x);
}
```
```rust
fn main() {
  let x = plus_one(5);
  println!("The value of x is {}", x);
}

fn plus_one(x: i32) -> i32 {
  // 假如我们给函数 plus_one结尾处的x + 1加上分号(如下所示)，那么这个表达式就会 变为语句并进而导致编译时错误
  x + 1
}
```




## 注释
```rust
// hello world
```

## 控制流
### if表达式
值得注意的是，代码中的条件表达式必须产生一个bool类型的 值，否则就会触发编译错误。
```rust
fn main() {
  let number = 3;
  if number < 5 {
    println!("condition was true");
  } else {
    println!("condition was false");
  }
}
```
这个错误表明Rust期望在条件表达式中获得一个bool值，而不是 一个整数。与Ruby或JavaScript等语言不同，Rust不会自动尝试将非 布尔类型的值转换为布尔类型。你必须显式地在if表达式中提供一个 布尔类型作为条件。
```rust
fn main() {
  let number = 3;
  if number {
    println!("number was three");
  } 
  if number != 0 {
    println!("number was something other than zero");
  }
}
```
- 可以使用else if实现多重条件判断
- 过多的else if表达式可能会使我们的代码变得杂乱无章
1. 在let语句中使用if
由于if是一个表达式，所以我们可以在let语句的右侧使用它来生成一个值
```rust
fn main() {
  let condition = true;
  let number = if condition {
    5
  } else {
    6
  };
  println!("The value of number is: {}", number);
}
```
- 代码块输出的值就是其中最后一个表达式的值，另外，数字本身也可以作为一个表达式使用
- 这也意味着，所有if分支可能返回的值都必须是一种类型的

### 使用循环重复执行代码
Rust提供了3种循环:loop、while和for
1. 使用loop重复执行代码
可以使用loop关键字来指示Rust反复执行某一块代码，直到我们显式地声明退出`CTRL+C`为止. Rust提供了另外一种更加可靠的循环退出方式。你可以在 循环中使用break关键字来通知程序退出循环
2. 从loop循环中返回值
loop循环可以被用来反复尝试一些可能会失败的操作，比如检查某个线程是否完成了自己的工作。不管怎么样，你也许会需要将该操作的结果传递给余下的代码。为了实现这一目的，我们可以将需要返 回的值添加到break表达式后面，也就是我们用来终止循环的表达式后面
```rust
fn main() {
  let mut counter = 12;
  let result = loop {
    counter += 1;
    if counter == 10 {
      // 一旦条件符合，我们便使用break关键字返回counter * 2
      break counter * 2;
    }
  };
  println!("The result is {}", result);
}
```
3. while条件循环
另外一种常见的循环模式是在每次执行循环体之前都判断一次条件，假如条件为真则执行代码片段，假如条件为假或在执行过程中碰 到break就退出当前循环。这种模式可以通过loop、if、else及break关键字的组合使用来实现
```rust
fn main() {
  let mut number = 3;
  while number != 0 {
    println!("{}!", number);
    number = number - 1;
  }
  println!("LIFTOFF!!!!");
}
```
使用loop、if、else及break来模拟条件循环，那么就会发现这个结构省去了很多冗余的内容，代码整体上会显得更加清晰。当条件为真时，执行循环体中的代码;否则，退出循环
4. 使用for来循环遍历集合
```rust
fn main() {
  let a = [10, 20, 30, 40, 50];
  for element in a.iter() {
    println!("the valus is: {}", element);
  }
}
```
for循环的安全性和简捷性使它成为了Rust中最为常用的循环结构
```rust
fn main() {
  for number in (1..4).rev() {
    println!("{}!", number);
  }
  println!("LIFTOFF!!!");
}
```











