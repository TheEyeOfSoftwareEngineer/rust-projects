## 认识所有权
- 所有权可以说是rust中最独特的一个功能
- 所有权的概念和相关工具的引入，rust才能够在没有垃圾回收机制的前提下保障内存安全

### 什么是所有权
- 一般来说，所有的程序都需要管理自己在运行时使用的计算机内存空间
- 某些使用垃圾回收机制的语言会在运行时定期检查并回收那些没有被继续使用的内存；而有的语言需要程序员手动地分配和释放内存
- rust采用第三种：它使用包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何的运行时开销
- 多了指针跳转的环节，所以访问堆上的数据要慢于访问栈上的数据。由于缓存的缘故，指令在内存中跳转的次数越多，性能就越差
- 处理器在操作排布紧密的数据(比如在栈上)时要比操作排布稀疏的数据(比如在堆上)有效率得多。另外，分配命令本身也可能消耗不少时钟周期
- 许多系统编程语言都需要你记录代码中分配的堆空间，最小化堆上的冗余数据，并及时清理堆上的无用数据以避免耗尽空间。而所有权的概念则解决了这些问题

### 所有权规则
- rust中的每一个值都有一个对应的变量作为它的所有者
- 在同一时间内，值有且仅有一个所有者
- 当所有者离开自己的作用域时，它持有的值就会被释放掉

### 变量作用域
- 作用域是一个对象在程序中有效的范围
- 变量在进入作用域后变得有效
- 会保持自己的有效性直到自己离开作用域为止

### String类型
- 字符串字面量是不可变的
- 并不是所有字符串的值都能够在编写代码时确定
- rust提供了字符串类型String，这个类型会在堆上分配到自己需要的存储空间，所以它能够处理在编译时未知大小的文本。可以调用from函数根据字符串字面量来创建一个String实例`let s = String::from("hello");`
```rust
let mut s = String::from("Hello");
s.push_str(", world!");
println!("{}", s); // Hello, world!
```
- String和字符串字面量采用了不同的内存处理方式所以前者可变后者不可变

### 内存与分配
- 对于字符串字面量而言，由于我们在编译时就知道其容，所以这部分硬编码的文本被直接嵌入到了最终的可执行文件中。这就是访问字符串字面量异常高效的原因,而这些性质完全得益于字符串字面 量的不可变性
- 我们没有办法将那些未知大小的文本在编 译期统统放入二进制文件中，更何况这些文本的大小还可能随着程序的运行而发生改变
- 对于String类型而言，为了支持一个可变的、可增长的文本类 型，我们需要在堆上分配一块在编译时未知大小的内存来存放数据。这同时也意味着:
  - 我们使用的内存是由操作系统在运行时动态分配出来的
  - 当使用完String时，我们需要通过某种方式来将这些内存归还给操作系统
- 第一步由程序员发起堆内存的分配请求
- 对于不同的编程语言来说，第二步实现起来就各有区别了
  - 在某些拥有垃圾回收 (Garbage Collector，GC)机制的语言中，GC会代替程序员来负责记录并清除那些不再使用的内存
  - 对于那些没有GC的语言来说，识别不再使用的内存并调用代码显式释放的工作就依然需要由程序员去完成，正如我们请求分配时一样
  - 假如我们忘记释放内存，那么就会造成内存泄漏;假如我们过早地释放内存，那么就会产生一个非法变量;假如我们重复释放同一块内存，那么就会 产生无法预知的后果。为了程序的稳定运行，我们必须严格地将分配和释放操作一一对应起来
  - Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。String类型的作者可以在这个函数中编写释放 内存的代码。记住，Rust会在作用域结束的地方(即}处)自动调用 drop函数。

1. 变量与数据交互的方式：移动
Rust中的多个变量可以采用一种独特的方式与同一数据进行交互
```rust
let x = 5;
let y = x;
```
将整数值5绑定到变量x 上;然后创建一个x值的拷贝，并将它绑定到y上。结果我们有了两个变量x和y，它们的值都是5。这正是实际发生的情形，因为整数是已知 固定大小的简单值，两个值5会同时被推入当前的栈中
```rust
let s1 = String::from("hello");
let s2 = s1;
```
String的内存布局，它实际上由3部分组成:
- 一个指向存放字符串内容的指针ptr
- 一个长度len
- 一个容量capacity
长度字段被用来记录当前String中的文本使用了多少字节的内存。而容量字段则被用来记录String向操作系统总共获取到的内存字节数量；当我们将s1赋值给s2时，便复制了一次String的数据，这意味着我们复制了它存储在栈上的指针、长度及容量字段。但需要注意的是，我们没有复制指针指向的堆数据

当我们将s1赋值给s2时，便复制了一次String的数据，这意味着 我们复制了它存储在栈上的指针、长度及容量字段。但需要注意的是，我们没有复制指针指向的堆数据

两个指针指向了同一个地址，这就导致了一个问题:当s2和s1离开自己的作用域时，它们会尝试去重复释放相同的内存。这也就是我们之前提到过的内存错误之一，臭名昭著的二次释 放。重复释放内存可能会导致某些正在使用的数据发生损坏，进而产生潜在的安全隐患

为了确保内存安全，同时也避免复制分配的内存，Rust在这种场 景下会简单地将s1废弃，不再视其为一个有效的变量。因此，Rust也不需要在s1离开作用域后清理任何东西。试图在s2创建完毕后使用s1会导致编译时错误
```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world", s1); // rust会产生错误提示
```
Rust同时使第一个变量无效了，所以我们使用了新的术语移动 (move)来描述这一行为，而不再使用浅度拷贝

这一语义完美地解决了我们的问题!既然只有s2有效，那么也就只有它会在离开自己的作用域时释放空间，所以再也没有二次释放的可能性了;另外，这里还隐含了另外一个设计原则:Rust永远不会自动地创建数据的深度拷贝。因此在Rust中，任何自动的赋值操作都可以被视为高效的

2. 变量和数据交互的方式：克隆
当你确实需要去深度拷贝String堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法
```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```
它显式地复制了堆上的数据。

当你看到某处调用了clone时，你就应该知道某些特定的代码将会被执行，而且这些代码可能会相当消耗资源。你可以很容易地在代码中察觉到一些不寻常的事情正在发生。

3. 栈上数据的复制
Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型.一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性。如果一种类型本身或这种类型的任意成员实现了Drop这 种trait，那么Rust就不允许其实现Copy这种trait。尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误

下面是一些拥有Copy这种trait的类型:
- 所有的整数类型，诸如u32
- 仅拥有两种值：true和false的布尔值bool
- 字符类型：char
- 所有的浮点类型，如f64
- 如果元组包含的所有字段的类型都是copy的，那么这个元组也是copy。如(i32, i32)是copy的，但是(i32, String)则不是

### 所有权与函数
将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样
```rust
fn main() {
  let s = String::from("hello"); // s进入作用域 
  takes_ownership(s); // s的值被移动到函数，所以它从这里开始不再有效
  let x = 5; // 变量x进入作用域
  makes_copy(x); // 变量x同样被传递进了函数
}
// x首先作用域，随后是s。但由于s的值已经发生了移动，所以没有什么特别的事情发生

fn takes_ownship(some_string: String) { // some_string进入作用域
  println!("{}", some_string);
} // some_string在这里离开作用月，drop函数被自动调用
// some_string所占用的内存也就随之被释放了

fn makes_copy(some_integer: i32) { // some_integer进入作用域
  println!("{}", some_integer);
} // some_integer在这里离开了作用域，没有什么特别的事情发生
```

### 返回值与作用域
函数在返回值的过程中也会发生所有权的转移
```rust
fn main() {
  let s1 = gives_ownership(); // 函数将它的返回值移动到s1中

  let s2 = String::from("Hello"); // s2进入作用域

  let s3 = takes_and_gives_back(s2); // s2移动到函数
  // takes_and_gives_back，函数的返回值被移动到s3上
} // s3在离开作用域并被销毁；s2已经移动了，不会在离开作用域时发生任何事情，s1最后离开作用域并被销毁

fn gives_ownership() -> String {
  let some_string = String::from("hello");
  some_string
}

fn takes_and_gives_back(a_string: String) -> String {
  a_string
}
```
变量所有权的转移总是遵循相同的模式:将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。

在所有的函数中都要获取所有权并返回所有权显得有些烦琐。假如你希望在调用函数时保留参数的所有权，那么就不得不将传入的值作为结果返回。除了这些需要保留所有权的值，函数还可能会返回它们本身的结果
```rust
fn main() {
  let s1 = String::from("Hello");
  let (s2, len) = calculate_length(s1);
  println!("The length of '{}' is {}", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
  let length = s.len();
  (s, length)
}
```
但这种写法未免太过笨拙了，类似的概念在编程工作中相当常 见。幸运的是，Rust针对这类场景提供了一个名为引用 的功能。

### 引用与借用
由于调用calculate_length会导致String移动到函数体内部，而我们又希望在调用完毕后继续使用该String，所以我们不得不使用元组将String作为元素再次返回. 与之前不同的是，新的函数签名使用了String的引用作为参数而没有直接转移值的所有权:
```rust
fn main() {
  let s1 = String::from("Hello");
  let len = calculate_length(&s1);
  println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
  s.len()
}
```
变量声明及函数返回值中的那些元组代码都消失了。其次，我们在调用calculate_length函数时使用了&s1作为参 数，且在该函数的定义中，我们使用&String替代了String. 这些&代表的就是*引用*语义，它们允许你在不获取所有权的前提下使用值
> 与使用&进行引用相反的操作被称为解引用(dereferencing)， 它使用*作为运算符
```rust
let s1 = String::from("hello");
let len = calculate_length(&s1);
```
这里的&s1语法允许我们在不转移所有权的前提下，创建一个指向 s1值的引用。由于引用不持有值的所有权，所以当引用离开当前作用域时，它指向的值也不会被丢弃。同理，函数签名中的&用来表明参数s的类型是一个引用。
```rust
fn calculate_length(s: &String) -> usize {
  s.len()
}
```
此处，变量s的有效作用域与其他任何函数参数一样，唯一不同的是，它不会在离开自己的作用域时销毁其指向的数据，因为它并不拥有该数据的所有权。当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有取得所有权。

这种通过引用传递参数给函数的方法也被称为借用 (borrowing)。
```rust
fn main() {
  let s = String::from("Hello");
  change(&s);
}

fn change(some_string: &String) {
  some_string.push_str(", world"); // 报错
}
```
与变量类似，引用是默认不可变的，Rust不允许我们去修改引用指向的值。

### 可变引用
```rust
fn main() {
  let mut s = String::from("hello");
  change(&mut s);
}

fn change(some_string: &mut String) {
  some_string.push_str(", world");
}
```
首先，我们需要将变量s声明为mut，即可变的。其次，我们使用`&mut s`来给函数传入一个可变引用，并将函数签名修改为`some_string: &mut String`来使其可以接收一个可变引用作为参数

但可变引用在使用上有一个很大的限制:对于特定作用域中的特 定数据来说，一次只能声明一个可变引用。以下代码尝试违背这一限制，则会导致编译错误
```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s; // cannot borrow `s` as mutable more than once at a time
```
这个规则使得引用的可变性只能以一种受到严格限制的方式来使用。许多刚刚接触Rust的开发者会反复地与它进行斗争，因为大部分的语言都允许你随意修改变量

但另一方面，在Rust中遵循这条限制性规则可以帮助我们在编译时避免数据竞争。数据竞争 (data race)与竞态条件十分类似，它会在指令满足以下3种情形时发生:
- 两个或两个以上的指针同时访问统一空间
- 其中至少有一个指针会向空间中写入数据
- 没有同步数据访问的机制
数据竞争会导致未定义的行为，由于这些未定义的行为往往难以在运行时进行跟踪，也就使得出现的bug更加难以被诊断和修复。Rust则完美地避免了这种情形的出现，因为存在数据竞争的代码连编译检查都无法通过!

与大部分语言类似，我们可以通过花括号来创建一个新的作用域范围。这就使我们可以创建多个可变引用，当然，这些可变引用不会同时存在:
```rust
let mut s = String::from("hello");
{
  let r1 = &mut s;
}
let r2 = &mut s;
```
在结合使用可变引用与不可变引用时，还有另外一条类似的限制 规则，它会导致下面的代码编译失败:
```rust
let mut s = String::from("Hello");

let r1 = &s;
let r2 = &s;
let r3 = &mut s; // error
```
我们不能在拥有不可变引用的同时创建可变引用

### 悬垂引用
使用拥有指针概念的语言会非常容易错误地创建出悬垂指针 。这类指针指向曾经存在的某处内存地址，但该内存已经被释放掉甚至是被重新分配另作他用了。而在Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。假如我们当前持有某个数据的引用，那么编译器可以保证这个数据不会在引用被销毁前离开自己的作用域。
```rust
fn main() {
  let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle会返回一个指向String的引用
  let s = String::from("hello"); // s被绑定到新的String上
  &s // missing lifetime specifier
  // 我们将指向s的引用返回给调用者
} // 变量s在这里离开作用域并随之被销毁，它指向的内存自然也不再有效
```
由于变量s创建在函数dangle内，所以它会在dangle执行完毕时随之释放。但是，我们的代码依旧尝试返回一个指向s的引用，这个引用指向的是一个无效的String。解决问题的方法，直接返回String：
```rust
fn no_dangle() -> String {
  let s = String::from("hello");
  s
}
```
这种写法没有任何问题，所有权被转移出函数，自然也就不会涉及释放操作了

### 引用的规则
- 在任何一段给定的时间里，要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用
- 引用总是有效的

## 切片
除了引用，Rust还有另外一种不持有所有权的数据类型:切片 (slice)。切片允许我们引用集合中某一段连续的元素序列，而不是整个集合。

编写一个搜索函数，它接收字符串作为参 数，并将字符串中的首个单词作为结果返回。如果字符串中不存在空 格，那么就意味着整个字符串是一个单词，直接返回整个字符串作为 结果即可。
```rust
fn first_word(s: &String) -> usize { // 将首歌单词结尾处的索引返回给调用者
  // 由于我们不需要获得传入值的所有权，所以这个函数first_word 采用了&String作为参数
  let bytes = s.as_bytes(); // as_bytes把String转换成字节数组
  for (i, &item) in bytes.iter().enumerate() { // iter方法创建一个可以便利字节数组的迭代器
    // 随后的enumerate 则将iter的每个输出作为元素逐一封装在对应的元组中返回。元组的 第一个元素是索引，第二个元素是指向集合中字节的引用。使用 enumerate可以较为方便地获得迭代索引
    // iter().enumerate()中获取的是产生引用元素的迭代器，所以我们在模式中使用了&
    if item == b' ' {
      return i;
    }
  }
  s.len()
}
```
```rust
fn main() {
  let mut s = String::from("hello world");
  let word = first_word(&s); // 索引5会被绑定到变量word上
  s.clear(); // clear方法会清空当前字符串，使之变为""
  // 虽然word依然拥有5这个值，但因为我们用域搜索的字符串发生了改变
  // 所以这个索引也就没有任何意义了，word到这里便失去了有效性
}
```
上面的程序在编译器看来没有任何问题，即便我们在调用 s.clear()之后使用word变量也是没有问题的。同时由于word变量本身与s没有任何关联，所以word的值始终都是5。但当我们再次使用5去从 变量s中提取单词时，一个bug就出现了:此时s中的内容早已在我们将5存入word后发生了改变

这种API的设计方式使我们需要随时关注word的有效性，确保它与s中的数据是一致的，类似的工作往往相当烦琐且易于出错。这种情况对于另一个函数second_word而言更加明显。这个函数被设计来搜索字符串中的第二个单词，它的签名也许会被设计为下面这样:
```rust
fn second_word(s: &String) -> (usize, usize) {
  // ...
}
```
现在，我们需要同时维护起始和结束两个位置的索引，这两个值 基于数据的某个特定状态计算而来，却没有跟数据产生任何程度上的联系。

### 字符串切片
字符串切片是指向String对象中某个连续部分的引用，它的使用方式如下所示:
```rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
```
这里的语法与创建指向整个String对象的引用有些相似，但不同的是，新语法在结尾的地方多出了一段`[0..5]`。这段额外的声明告诉编译器我们正在创建一个String的切片引用，而不是对整个字符串本身的引用。

我们可以在一对方括号中指定切片的范围区间`[starting_index.. ending_index]`，其中的starting_index是切片起始位置的索引值，ending_index是切片终止位置的下一个索引值。切片数据结构在内部存储了指向起始位置的引用和一个描述切片长度的字段，这个描述切片长度的字段等价于ending_index减去starting_index。

Rust的范围语法`..`有一个小小的语法糖:当你希望范围从第一个元素(也就是索引值为0的元素)开始时，则可以省略两个点号之前的值。换句话说，下面两个创建切片的表达式是等价的:
```rust
let s = String::from("hello");
let slice = &s[0..2];
let slice = &s[..2]
```
同样地，假如你的切片想要包含String中的最后一个字节，你也可以省略双点号之后的值。下面的切片表达式依然是等价的:
```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[3..len];
let slice = &s[3..]
```
你甚至可以同时省略首尾的两个值，来创建一个指向整个字符串所有字节的切片:
```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[0..len];
let slice = &s[..]
```
开始重构first_word函数吧。该 函数可以返回一个切片作为结果。字符串切片的类型写作&str:
```rust
fn first_word(s: $String) -> &str {
  let bytes = s.as_bytes();
  for (i, &item) in bytes.iter().enumerate() {
    if item == b' ' {
      return &s[0..i];
    }
  }
  &s[..]
}
```
一旦搜索成功，就返回一个从首字符开始到这个索引位置结束的字符串切片。调用新的first_word函数会返回一个与底层数据紧密联系的切片作为结果，它由指向起始位置的引用和描述元素长度的字段组成。
```rust
fn main() {
  let mut s = String::from("hello");
  let word = first_word(&s);
  s.clear(); // error
  println!("the first word is {}", word);
}
```
当我们拥有了某个变量的不可变引用时，我们就无法同时取得该变量的可变引用。由于clear需要截断当前的 String实例，所以调用clear需要传入一个可变引用。这就是编译失败的原因。
1. 字符串字面量就是切片
```rust
let s = "Hello, world!"
```
在这里，变量s的类型其实就是&str:它是一个指向二进制程序特定位置的切片。正是由于&str是一个不可变的引用，所以字符串字面量自然才是不可变的。
2. 将字符串切片作为参数
既然我们可以分别创建字符串字面量和String的切片，那么就能够进一步优化first_word函数的接口
```rust
fn first_word(s: &String) -> &str { 
  // ... 
}
```
比较有经验的Rust开发者往往会采用下面的写法，这种改进后的签名使函数可以同时处理String与&str:
```rust
fn first_word(s: &str) -> &str {
  // ...
}
```
当你持有字符串切片时，你可以直接调用这个函数。而当你持有String时，你可以创建一个完整String的切片来作为参数。在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用，且不会损失任何功能
```rust
fn main() {
  let my_string = String::from("hello world");
  let word = first_word(&my_string[..]);
  let my_string_literal = "hello world";
  let word = first_word(&my_string_literal[..]);
  let word = first_word(my_string_literal);
}
```

### 其他类型的切片
从名字上就可以看出来，字符串切片是专门用于字符串的。但实际上，Rust还有其他更加通用的切片类型，以下面的数组为例:
```rust
let a = [1, 2, 3, 4, 5];
```
就像我们想要引用字符串的某个部分一样，你也可能会希望引用数组的某个部分。这时，我们可以这样做:
```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```
这里的切片类型是`&[i32]`，它在内部存储了一个指向起始元素的引用及长度，这与字符串切片的工作机制完全一样。

所有权、借用和切片的概念是Rust可以在编译时保证内存安全的关键所在。










